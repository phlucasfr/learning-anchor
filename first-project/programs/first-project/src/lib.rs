use anchor_lang::prelude::*;

declare_id!("26y2PsQLLgofc2i73kwGVLUmE1bdHuC6yNPdhEuyXNHr"); // Specifies the program's on-chain address

#[program] // Specifies the module containing the programâ€™s instruction logic
pub mod first_project {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>, data: u64) -> Result<()> {
        ctx.accounts.new_account.data = data;
        msg!("Changed data to: {}!", data);
        Ok(())
    }
}

#[derive(Accounts)] // Applied to structs to indicate a list of accounts required by an instruction
pub struct Initialize<'info> {
    #[account(init, payer = signer, space = 8 + 8)]
    pub new_account: Account<'info, NewAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[account] // Applied to structs to create custom account types for the program
pub struct NewAccount {
    data: u64,
}

// The Context type provides the instruction with access to the following non-argument inputs:
// pub struct Context<'a, 'b, 'c, 'info, T: Bumps> {
//     /// Currently executing program id.
//     pub program_id: &'a Pubkey,
//     /// Deserialized accounts.
//     pub accounts: &'b mut T,
//     /// Remaining accounts given but not deserialized or validated.
//     /// Be very careful when using this directly.
//     pub remaining_accounts: &'c [AccountInfo<'info>],
//     /// Bump seeds found during constraint validation. This is provided as a
//     /// convenience so that handlers don't have to recalculate bump seeds or
//     /// pass them in as arguments.
//     /// Type is the bumps struct generated by #[derive(Accounts)]
//     pub bumps: T::Bumps,
// }